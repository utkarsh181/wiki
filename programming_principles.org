#+TITLE: Programming Principles Using C++
#+AUTHOR: Utkarsh Singh

* Generic Programming
Generic programming: Writing code that works with a variety of types presented as
arguments, as long as those argument types meet specific syntactic and semantic
requirements.

Templates are the basis for generic programming in C++.
Basically, a template is a mechanism that allows a programmer to use types as parameters
for a class or a function. The compiler then generates a specific class or function when we
later provide specific types as arguments.
#+begin_src c++
  template<typename T>
  struct S {
    S():
      al{T()} {}
    S(T x)
      val{x} {}
    T& get();
    void set(const T& x) { val = x;}
    T& operator=(const T& x);
  private:
    T val;
  };
#+end_src
** Resource management problems
*** 'new' and 'delete' pair
#+begin_src C++
  void suspicious(int *q, int x)
  {
    int *p = new int[100];
    if(x) p = q;
    delete[] p; // p may point to diff loacation
  }
#+end_src
*** expection problem
#+begin_src c++
  void suspicious(int s, int x)
  {
    int *p = new int[s];
    vector<int> v;
    if(x) p[x] = v.at(x); // at may throw range error
    delete[] p;
  }
#+end_src
In the second case if you consider to tackle problem using try...catch block the technique may work but
it will make code repetitive and ugly.
** RAII - Resource Acquisition Is Initialisation
We don't need to plaster our code with try...catch blocks to deal with resource leak.
#+begin_src c++
  void f(vector<int>& v, int x)
  {
    vector<int> p(x);
    vetor<int> q(x);
  }
#+end_src
In this case resource is acquired during initialisation using constructor and released using destructor.
** Guarantee
Sometimes RAII technique fails, for ex:
#+begin_src c++
  vector<int>* make_vec(int s)
  {
    vector<int>* p = new vector<int>
      try{
	for(int i=0; i<10; i++) p->push_back(i);
	return;
      }
      catch(...){
	delete p;
	throw;
      }
  }
#+end_src
Above program solves the problem of RAII failure using basic guarantee.
Types of Guarantee :
1. Basic Guarantee - in case of failure throw error and hand resource back to program.
2. Strong Guarantee - basic guarantee + all the observable value should remain same after throw.
3. No Guarantee
** 'smart pointer' - return of RAII
'smart pointer' automatically manages memory and deallocate them when not in use.
#+begin_src c++
  template <typename T, typename A>
  void Vector<T, A>::reserve(int new_alloc)
  {
    if (new_alloc <= space) return;   // never decrease allocation

    unique_ptr<T> p{alloc.allocate(new_alloc)};
    for (int i=0; i<sz; i++) alloc.construct(&p.get()[i], elem[i]); // copy
    for (int i=0; i<sz; i++) alloc.destroy(&elem[i]);
    alloc.deallocate(elem, space); // deallocate old space
    elem = p.release();
    space = new_alloc;
  }
#+end_src
'smart_pointer' solves our previous problem in the RAII way. It owns the pointer it points
to which means that if exception is thrown while the vector is filled then it insures
then vector is properly destroyed.
* Containers and iterators
Generalizing Code - To 'find' a uniform way of accessing data and manipulating data so that we
don't have to write our code differently each time data is presented in slightly different way.

How to make our code generalized?

Niche example of how to find highest element that will work with both vector and arrays.
#+begin_src c++
  double* find_highest(double* first, double* last)
  {
    double* high = first;
    while(first != last){
      if(*high < *first) high = first;
      first++;
    }
    return high;
  }
#+end_src
** Working with data
When we write code to compute on data these should be our ideals:
1. Uniform access to data
2. Independently of how it is stored
3. Independently of its type
4. Type-safe access to data
5. Easy traversal of data
6. Compact storage of data
7. Fast Retrieval of data
8. Addition of data
9. Deletion of data
10. Standard versions of the most common algorithms
11. Such as copy, find, search, sort, sum, . . .
** Sequences and iterators
A sequence is collection of data, mathematically denoted is [begin:end). Here, begin and end are iterators.
Iterators are used to connect algorithms to data. When using iterators provides independence between algorithms
and containers.
